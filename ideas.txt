JARGON
--> subject --> pier@usrz.com                        --> identifies "who"
--> browser --> f3ebffa1-9593-41cd-8937-b2bc4851df44 --> identifies a browser, has a secret
--> service --> 66071dab-679c-4cf3-b331-f2b5f68d7f63 --> identifies a service, has an ecdsa key

browser should do scram first w/o subject/service

----> BROWSER w/o identifier

... we are still vulnerable to dictionary attacks if a man in the middle
    can eavesdrop on the connection, as in:
    - MIM can derive the auth_message (it's in the clear)
    - MIM gets a dictionary of all passwords, computes KDF
    - MIM tries replicating session
    - for https://crackstation.net/buy-crackstation-wordlist-password-cracking-dictionary.htm
      - 1,493,677,782 passwords
      - SHA256 w/ 65536 is ~ 50ms per core, 20 pwd/sec
      - AWS c3.8xlarge = 32 cores, $1.68/hour, 640 pwd/sec
      - approx 648h or 27 days on a single machine
      - around US$ 1089
      - FUCK!
... webcrypto https://infotechinc.github.io/password-based-key-derivation-in-browser/

================================================================================

send in client first:
- sub: the subject
- dev: the device ID
send in server first
- pwd: the subject's password
- otp: the subject's OTP
- dev: the device secret key




{ sub: "pier" }
-> { pwd: 1000, SHA256 },
   { otp: 1, SHA256 }
{ prf: ... base64 ... }


I have a browser Key...

{ sub: "pier",
  dev: "f3ebffa1-9593-41cd-8937-b2bc4851df44" }
-> { dev: 1000, SHA256 }
{ prf: ... base64 ... }

-> { pwd: ...,
     otp: ... }
{ prf: ... base64 ... }


{ sub, dev } --> [ pwd, otp ] -> { prf } -> [ key, tok ]
{ dev } --> 401 --> { sub, dev } --> { [ pwd, otp ] }
{ dev } --> { [ ] }


browser +



================================================================================

client_first {
  msg: { // this will be base 64
    nonce: ... a nonce ...
    ecdhe: ... the ecdhe public key ...
    ecdsa: ... the ecdsa public key ...

    subject: "pier@usrz.com"
    service: "66071dab-679c-4cf3-b331-f2b5f68d7f63" // optional
  }
  sig: ... base64 ecdsa of "msg" ...
}

server_first {
  msg: { // this will be base 64
    nonce: ... a nonce ...
    ecdhe: ... the ecdhe public key ...
    ecdsa: ... the ecdsa public key ...

    hash: ... the hash ...

    spec: { ... kdf spec ... }
  },
  sig: ... base64 ecdsa of "msg" ...
}

URL := timestamp + "." + hmac(secret, timestamp + client_first + server_first))

AUTH_MESSAGE := client_first + server_first

client_final {
  prf: ... base64 ...,
  sig: ... base64 of ECDSA(client_key) ...
}

server_final {
  prf: ... base64 ...
  sig: ... base64 of ECDSA(client_key) ...
}

SECRET_KEY := HMAC(ecdh, auth_message + client_final + server_final)

/* ========================================================================== */

>>>>> CLIENT REQUESTS
 { client_first: "... base64 ..." }
<<<<< SERVER RESPONDS
 { client_first: "... base64 ..." ,
   server_first: "... base64 ..." }

>>>>> CLIENT REQUESTS
 { client_first: "... base64 ..." ,
   server_first: "... base64 ..." ,
   client_final: "... base64 ..." }
<<<<< SERVER RESPONDS
 { client_first: "... base64 ..." ,
   server_first: "... base64 ..." ,
   client_final: "... base64 ..." ,
   server_final: "... base64 ..." }

/* ========================================================================== */

BEARER_TOKEN := ... subject, browser, service, encrypted_shared_key, ...
 -> iss -> issuer (identify key for encryption?)
 -> sub -> subject
 -> aud -> audience (service)
 -> azp -> authorized party (browser)
 -> jti -> jwt id (encrypt shared key?)
 -> exp, nbf, iat -> times
 -- http://www.iana.org/assignments/jwt/jwt.xhtml

